%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% PREAMBLE %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

%\VignetteIndexEntry{rrapply: revisiting R-base rapply}
%\VignetteAuthor{Joris Chau}
%\VignetteKeyword{introduction}
%\VignetteKeyword{rapply}
%\VignetteKeyword{rrapply}
%\VignetteEncoding{UTF-8}

\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}
\pdfstringdefDisableCommands{%
\def\\{}%
\def\texttt#1{<#1>}%
}
\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\addtolength{\oddsidemargin}{-.6in}%
\addtolength{\evensidemargin}{-.6in}%
\addtolength{\textwidth}{1.2in}%
\addtolength{\textheight}{1.3in}%
\addtolength{\topmargin}{-.8in}%

\newenvironment{remark}[1][Remark.]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\te}[1]{\textnormal{#1}}
\makeatletter
\newcommand*\rel@kern[1]{\kern#1\dimexpr\macc@kerna}
\newcommand*\widebar[1]{%
\begingroup
\def\mathaccent##1##2{%
\rel@kern{0.8}%
\overline{\rel@kern{-0.8}\macc@nucleus\rel@kern{0.2}}%
\rel@kern{-0.2}%
}%
\macc@depth\@ne
\let\math@bgroup\@empty \let\math@egroup\macc@set@skewchar
\mathsurround\z@ \frozen@everymath{\mathgroup\macc@group\relax}%
\macc@set@skewchar\relax
\let\mathaccentV\macc@nested@a
\macc@nested@a\relax111{#1}%
\endgroup
}
\makeatother

%%%%%%%%%%%%%%%%%%%%
%%%%%%% BODY %%%%%%%
%%%%%%%%%%%%%%%%%%%%

\begin{document}
\SweaveOpts{concordance=TRUE}

\def\spacingset#1{\renewcommand{\baselinestretch}%
{#1}\small\normalsize} \spacingset{1}


<<echo=false>>=
op <- options(width = 60, continue = "  ")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% TITLE + ABSTRACT %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\texttt{rrapply}: revisiting \textsf{R}-base \texttt{rapply}}
\author{Joris Chau}
\date{\today}
\maketitle

\spacingset{1.25} 

\begin{abstract} 
\noindent 
The \texttt{rrapply}-package contains a single function \code{rrapply}, providing an extended implementation of \textsf{R}-base's \code{rapply} function. Base \code{rapply} applies a function \code{f} to all elements of a list recursively. The \code{rrapply} function extends base \code{rapply} by including a condition or predicate function for the application of \code{f} and the option to prune or aggregate list elements from the result. In addition, special arguments \code{.xname} and \code{.xpos} can be used inside the \code{f} and \code{condition} functions to access the name and location in the nested list of the list element under evaluation. The \code{rrapply} function is implemented using \textsf{R}'s \textsf{C} interface and for this reason requires no external \textsf{R}-package dependencies. 
\end{abstract}

\spacingset{1.45} 

\section{Quick review of \texttt{rapply}}

The dataset \code{renewable\_energy\_by\_country} included in the \texttt{rrapply}-package lists the share of renewable energy as a percentage in the total energy consumption per country in 2016. The dataset is publicly available at the United Nations Open SDG Data Hub (\href{https://unstats-undesa.opendata.arcgis.com/datasets/indicator-7-2-1-renewable-energy-share-in-the-total-final-energy-consumption-percent-3}{UNSD-SDG07}). The 249 countries and areas are structured as a nested list based on their geographical location according to the United Nations M49 standard (\href{https://unstats.un.org/unsd/methodology/m49/}{UNSD-M49}). The numeric values listed for each country are percentages, if no data is available the country's value is \code{NA}.
<<>>=
library(rrapply)
data("renewable_energy_by_country")
## display list structure (only first two elements of each node)
str(renewable_energy_by_country, list.len = 2, give.attr = FALSE)
@
For convenience, we subset only the values for countries and areas in \code{Oceania},
<<>>=
renewable_oceania <- renewable_energy_by_country[["World"]]["Oceania"]
str(renewable_oceania, list.len = 3, give.attr = FALSE)
@
Using base \code{rapply}, we can apply a function \code{f} to each leaf element or leaf elements of a particular class or type. By a leaf element, we refer to any element of the list which is not itself list-like, in this case the numeric country percentages. For instance, we can replace all \code{NA}'s by zeros using an \code{ifelse} statement in the \code{f} function, 
<<>>=
na_zero_oceania_unlist <- rapply(
  renewable_oceania, 
  f = function(x) ifelse(is.na(x), 0, x)
)
head(na_zero_oceania_unlist)
@
By default, the result is returned \emph{unlisted}. The original list structure can be preserved via the arguments \code{how = "replace"} or \code{how = "list"}. Conceptually, \code{how = "replace"} makes a complete copy of the input list and recursively replaces the leaf elements with a class in \code{classes} by the result of applying \code{f}. \code{how = "list"} recursively makes copies of the list-like elements of the input list, replacing leaf elements with a class in \code{classes} by the result of applying \code{f}, and replacing any other leaf elements by the value of \code{deflt}. \code{how = "unlist"} calls \code{unlist()} with argument \code{recursive = TRUE} on the initial result obtained by \code{how = "list"}, thus allowing the use of the \code{deflt} argument.\\[3mm]
By making use of the fact that the \code{NA}'s are of \code{logical} type and the non-\code{NA}'s are of \code{numeric} type, another way of replacing \code{NA}'s by zeros is via the \code{classes} argument:
<<>>=
na_zero_oceania_replace <- rapply(
  renewable_oceania, 
  f = function(x) 0, 
  classes = "logical", 
  how = "replace"
)
str(na_zero_oceania_replace, list.len = 3, give.attr = FALSE)
@
Or, by combining the \code{classes} and \code{deflt} arguments together with \code{how = "list"} or \code{how = "unlist"}, 
<<>>=
na_zero_oceania_list <- rapply(
  renewable_oceania, 
  f = function(x) x, 
  classes = "numeric", 
  deflt = 0, 
  how = "list"
)
str(na_zero_oceania_list, list.len = 3, give.attr = FALSE)
@
Each list element in \code{renewable\_energy\_by\_country} contains an \code{"M49-code"} attribute with the ``UN Standard Country or Area Codes for Statistical Use (Series M, No. 49)''. In order to keep this attribute when replacing \code{NA}'s by zeros, we could modify the above call with \code{how = "replace"} to,
<<>>=
na_zero_oceania_replace_attr <- rapply(
  renewable_oceania, 
  f = function(x) replace(x, is.na(x), 0), 
  how = "replace"
)
str(na_zero_oceania_replace_attr, list.len = 2)
@
With \code{how = "list"}, intermediate list attributes --excluding the leaf elements-- are in general not preserved. For this reason, it is probably best to use \code{how = "replace"} whenever possible if list attributes are present and must be preserved. 
<<>>=
na_zero_oceania_list_attr <- rapply(
  renewable_oceania, 
  f = function(x) replace(x, is.na(x), 0), 
  how = "list"
)
## this preserves all list attributes
str(na_zero_oceania_replace_attr, max.level = 2)
## this does not preserves all attributes!
str(na_zero_oceania_list_attr, max.level = 2)
@

\section{When to use \texttt{rrapply}}

\subsection{List pruning}

With base \code{rapply} there is no convenient way to prune or filter leaf elements from the input list. Using the \code{deflt} argument, we could set all leaf elements that are not subject to application of \code{f} to e.g. \code{NA} or \code{NULL}, but we cannot drop these leaf elements altogether from the resulting list.\\[3mm]
The \code{rrapply} function adds an option to set the \code{how} argument to \code{how = "prune"}, in which case all leaf elements that are not subject to application of \code{f} are pruned from the list. The original list structure is retained, similar to the non-pruned options \code{how = "replace"} or \code{how = "list"}. \\[3mm]
Using \code{how = "prune"}, we can drop all \code{NA} elements while preserving the original list structure:
<<>>=
na_drop_oceania_list <- rrapply(
  renewable_oceania, 
  f = function(x) x, 
  classes = "numeric", 
  how = "prune"
)
str(na_drop_oceania_list, list.len = 3, give.attr = FALSE)
@
Instead, we can set \code{how = "flatten"} to return a flattened unnested version of the pruned list. This is more efficient than first returning the pruned list with \code{how = "prune"} and unlisting or flattening the list in a subsequent step. 
<<>>=
na_drop_oceania_flat <- rrapply(
  renewable_oceania, 
  f = function(x) x, 
  classes = "numeric", 
  how = "flatten"
)
str(na_drop_oceania_flat, list.len = 10, give.attr = FALSE)
@
Another option is to set \code{how = "melt"} to return a melted data.frame of the pruned list similar in format to \code{reshape2::melt} applied to a nested list. The rows of the melted data.frame contain the node paths of the elements in the pruned list. The \code{"value"} column is a list-column with the values of the terminal nodes analogous to the flattened list returned by \code{how = "flatten"}. 
<<>>=
na_drop_melt <- rrapply(
  renewable_oceania,
  f = function(x) x,
  classes = "numeric",
  how = "melt"
)
head(na_drop_melt)
@
If no names are present in a sublist of the input list, \code{how = "melt"} replaces the names in the melted data.frame by the list element indices \code{"..1"}, \code{"..2"}, and so on:
<<>>=
## Remove all names at L2 (these arguments are explained in the following sections)
oceania_unnamed <- rrapply(
  renewable_oceania,
  condition = function(x, .xpos) length(.xpos) < 2,
  f = unname,
  feverywhere = "break"
)

na_drop_melt2 <- rrapply(
  oceania_unnamed,
  f = function(x) x,
  classes = "numeric",
  how = "melt"
)
head(na_drop_melt2)
@

\subsection{Condition function}

Base \code{rapply} allows to apply \code{f} to leaf elements of certain types or classes via the \code{classes} argument, which might not always provide sufficient control to partition leaf elements. For this purpose, \code{rrapply} includes an additional \code{condition} argument, which accepts any principal argument function to use as a condition or predicate to select leaf elements to which \code{f} is applied. Conceptually, the \code{f} function is applied to all leaf
elements for which the \code{condition} function exactly evaluates to \code{TRUE} similar to the \code{isTRUE} function. If the \code{condition} function is missing, \code{f} is applied to all leaf elements. In combination with \code{how = "prune"}, the \code{condition} function provides a flexible way to select and filter elements from the nested list.\\[3mm]
Using the \code{condition} argument, we can update the above function call to better reflect our purpose:
<<>>=
na_drop_oceania_list2 <- rrapply(
  renewable_oceania, 
  condition = function(x) !is.na(x), 
  f = function(x) x, 
  how = "prune"
)
str(na_drop_oceania_list2, list.len = 3, give.attr = FALSE)
@
\code{rrapply} allows the \code{f} argument to be missing, in which case no function is applied to the leaf elements. Using the \code{Negate} function, we can rewrite the above expression somewhat more concisely as, 
<<>>=
na_drop_oceania_list3 <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  how = "prune"
)
str(na_drop_oceania_list3, list.len = 3, give.attr = FALSE)
@
A more interesting example is to consider a \code{condition} that is not also replicable using the \code{classes} argument. For instance, we can filter all countries with a renewable
energy share above 85 percent, or all countries with a renewable energy share
of 0 percent: 
<<>>=
renewable_energy_above_85 <- rrapply(
  renewable_energy_by_country, 
  condition = function(x) x > 85, 
  how = "prune"
)
str(renewable_energy_above_85, give.attr = FALSE)
## passing arguments to condition via ...
renewable_energy_equal_0 <- rrapply(
  renewable_energy_by_country, 
  condition = `==`, 
  e2 = 0, 
  how = "prune"
)
str(renewable_energy_equal_0, give.attr = FALSE)
@
Note that the \code{NA} elements are not returned, as the \code{condition} does not evaluate to \code{TRUE} for \code{NA} values. \\[3mm]
As the \code{condition} function is a generalization of the \code{classes} argument to have more
flexible control of the predicate, it is also possible to use the \code{deflt} argument
together with \code{how = "list"} or \code{how = "unlist"} to set a default value to all
leaf elements for which the \code{condition} does not evaluate to \code{TRUE}:
<<>>=
na_zero_oceania_list2 <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  deflt = 0, 
  how = "list"
)
str(na_zero_oceania_list2, list.len = 3, give.attr = FALSE)
@
To be consistent with base \code{rapply}, the \code{deflt} argument can still only be used
together with \code{how = "list"} or \code{how = "unlist"}. With \code{how = "replace"}, we can replace \code{NA} values by zeros using the \code{f} function in the same way as before, 
<<>>=
na_zero_oceania_replace2 <- rrapply(
  renewable_oceania, 
  condition = is.na, 
  f = function(x) 0, 
  how = "replace"
)
str(na_zero_oceania_replace2, list.len = 3, give.attr = FALSE)
@
\subsubsection{Using the \texttt{...} argument}

In base \code{rapply}, the first argument to \code{f} always evaluates to the content of
the leaf element to which \code{f} is applied. Any further arguments (besides the special arguments \code{.xname} and \code{.xpos} discussed below) that are independent of the node content are supplied via the dots \code{...} argument. Since \code{rrapply} accepts a function in two of its arguments \code{f} and \code{condition}, any further arguments defined via the \code{dots} also need to be defined as function arguments in \emph{both} the \code{f} and \code{condition} function (if existing), even if they are not used in the function itself.\\[3mm]
To illustrate, consider the following example where we replace all \code{NA} elements by a value defined in a separate argument \code{newvalue}:
<<>>=
## this is not ok!
tryCatch({
  rrapply(
    renewable_oceania, 
    condition = is.na, 
    f = function(x, newvalue) newvalue, 
    newvalue = 0, 
    how = "replace"
  )
}, error = function(error) error$message)
## this is ok
na_zero_oceania_replace3 <- rrapply(
  renewable_oceania, 
  condition = function(x, newvalue) is.na(x), 
  f = function(x, newvalue) newvalue, 
  newvalue = 0, 
  how = "replace"
)
str(na_zero_oceania_replace3, list.len = 3, give.attr = FALSE)
@
\subsection{Special arguments \texttt{.xname} and \texttt{.xpos}}

For illustration purposes, let us return all non-missing values in
\code{renewable\_oceania} as a non-nested flattened list:
<<>>=
renewable_oceania_flat <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  how = "flatten"
)
str(renewable_oceania_flat, list.len = 10, give.attr = FALSE)
@
Suppose that we wish to apply a function to each list element that relies on the name of the node. A possible way to achieve this using \code{mapply} would be:
<<>>=
renewable_oceania_flat_text <- mapply(
  FUN = function(name, value) sprintf("Renewable energy in %s: %.2f%%", name, value),
  name = names(renewable_oceania_flat),
  value = renewable_oceania_flat,
  SIMPLIFY = FALSE
)
str(renewable_oceania_flat_text, list.len = 10)
@
\begin{remark}
Note that the \texttt{purrr}-package also contains the convenience function \code{imap} for exactly this purpose.
\end{remark}
In base \code{rapply}, the \code{f} function only has access to the content of a leaf
element through its principal argument, but there is no convenient way to access the list element its name or location from
inside the \code{f} function. This makes \code{rapply} impractical if we want to apply
a function \code{f} that relies on e.g. the name of the leaf element as in the above example.\\[3mm]
To address this issue, \code{rrapply} allows the use of two special arguments 
\code{.xname} and \code{.xpos} in addition to the principal argument in the \code{f} and \code{condition} functions. The \code{.xname} argument evaluates to the name of the leaf element. The \code{.xpos} argument evaluates to the position of the leaf element in the nested list structured as an integer vector. For instance, if \code{x = list(list("y", "z"))}, then an \code{.xpos} location of \code{c(1, 2)} corresponds to the leaf element \code{x[[1]][[2]]} or equivalently
\code{x[[c(1, 2)]]}. The arguments \code{.xname} and \code{.xpos} need to be defined explicitly as function arguments in \code{f} and \code{condition} whenever they are used. Note that the principal function arguments of \code{f} and \code{condition} always evaluate to the content of the list element, for this reason the arguments \code{.xname} or \code{.xpos} should always be defined in addition to a principal function argument.\\[3mm]
Using the \code{.xname} argument, we can reproduce the \code{mapply} example above also from a nested list as input:
<<>>=
renewable_oceania_flat_text <- rrapply(
  renewable_oceania,
  f = function(x, .xname) sprintf("Renewable energy in %s: %.2f%%", .xname, x),
  condition = Negate(is.na),
  how = "flatten"
)
str(renewable_oceania_flat_text, list.len = 10)
@
Since the \code{.xname} and \code{.xpos} arguments can also be used in the \code{condition} 
function, it is now possible to filter elements or apply a function only to a part of the list based on the node names or their positions.\\[3mm]
As an example, let us extract the renewable energy shares of Belgium, the Netherlands and
Luxembourg while preserving the nested structure of the filtered elements:
<<>>=
renewable_benelux <- rrapply(
  renewable_energy_by_country, 
  condition = function(x, .xname) .xname %in% c("Belgium", "Netherlands", "Luxembourg"), 
  how = "prune"
)
str(renewable_benelux, give.attr = FALSE)
@
Knowing that Europe is located under the node \code{renewable\_energy\_by\_country[[c(1, 5)]]}, we can filter all European countries
with a renewable energy share above 50 percent by using the \code{.xpos} argument,
<<>>=
renewable_europe_above_50 <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xpos) identical(head(.xpos, 2), c(1L, 5L)) & x > 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)
@
We could also look up the location of a particular country in the nested
list,
<<>>=
(xpos_sweden <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xname) identical(.xname, "Sweden"),
  f = function(x, .xpos) .xpos,
  how = "flatten"
))

## sanity check
renewable_energy_by_country[[xpos_sweden$Sweden]]
@
We could even use the \code{.xpos} argument to determine the maximum depth of the list
or the length of the longest sublist,
<<>>=
## maximum depth
depth_all <- rrapply(
  renewable_energy_by_country, 
  f = function(x, .xpos) length(.xpos), 
  how = "unlist"
)
max(depth_all) 
## longest sublist length
sublist_count <- rrapply(
  renewable_energy_by_country, 
  f = function(x, .xpos) max(.xpos), 
  how = "unlist"
)
max(sublist_count)
@

\subsection{List node aggregation}

By construction, both base \code{rapply} and \code{rrapply} apply the \code{f} function only to leaf elements of a nested list by recursing further into any list-like element that is encountered. In \code{rrapply}, it is possible to override this default behavior using the argument \code{feverywhere = "break"}. In this case, \code{rrapply} does not automatically recurse deeper into list-like objects, and the \code{f} function will be applied to any element (e.g. a sublist) that satisfies the \code{condition} and \code{classes} arguments. If the \code{condition} or \code{classes} arguments are not satisfied for a list-like element, \code{rrapply} will recurse further into the sublist, apply the \code{f} function to the nodes that satisfy \code{condition} and \code{classes}, and so on.\\[3mm]
A primary use of \code{feverywhere = "break"} is to perform node aggregation by calculating some type of summary statistic over sublists of the nested list. Together with the \code{.xname} and \code{.xpos} arguments, we have flexibility in deciding which sublists to summarize or collapse through the \code{condition} function.\\[3mm]
To illustrate, we can return the mean and standard deviation of the renewable energy share in Europe as follows:
<<>>=
rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xname) .xname == "Europe",
  f = function(x) list(
    mean = mean(unlist(x), na.rm = TRUE), 
    sd = sd(unlist(x), na.rm = TRUE)
  ),
  how = "flatten",
  feverywhere = "break"
)
@
\begin{remark}
Note that the principal \code{x} argument in the \code{f} function is now the entire sublist for which the \code{condition} is satisfied. For this reason, we first need to \code{unlist} the sublist in order to supply a numeric vector to \code{mean} and \code{sd}.
\end{remark}
The same result could be obtained by defining a \code{condition} based on the \code{"M49-code"} attribute of the list element. This can be convenient to filter or summarize nodes in nested lists coming from XML (or HTML) files based on their attribute values.
<<>>=
rrapply(
  renewable_energy_by_country,
  condition = function(x) attr(x, "M49-code") == "150",
  f = function(x) list(
    mean = mean(unlist(x), na.rm = TRUE), 
    sd = sd(unlist(x), na.rm = TRUE)
  ),
  how = "flatten",
  feverywhere = "break"
)
@
We can use the \code{.xpos} argument to apply the \code{f} function only at specific locations or depths in the nested list. For instance, we could return the mean renewable energy shares for each continent by observing that the \code{.xpos} vector of each continent has length (i.e. depth) 2:
<<>>=
renewable_continent_summary <- rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xpos) length(.xpos) == 2,
  f = function(x) mean(unlist(x), na.rm = TRUE),
  feverywhere = "break"
)

## Antarctica has a missing value
str(renewable_continent_summary, give.attr = FALSE)
@

\subsection{List node updating}

If \code{feverywhere = "break"}, \code{rrapply} will not recurse further into list-like elements after application of the \code{f} function. This makes it for instance impossible to recursively update the name of each element in the nested list as \code{rrapply} stops recursing after updating the first list layer. For this purpose, we can set \code{feverywhere = "recurse"} in which case \code{rrapply} recurses further into any \emph{updated} list-like element after application of the \code{f} function. In this context, the \code{condition} and \code{classes} arguments should be interpreted as a passing criterion (i.e. the opposite of a stopping criterion). As long as the \code{condition} and \code{classes} arguments are satisfied, \code{rrapply} will try to recurse further into any list-like elements.\\[3mm]
Using \code{feverywhere = "recurse"}, we can recursively replace all names in the nested list by their M49-codes:
<<>>=
renewable_M49 <- rrapply(
  list(renewable_energy_by_country), 
  condition = is.list,
  f = function(x) {
    names(x) <- vapply(x, attr, character(1L), which = "M49-code")
    return(x)
  },
  feverywhere = "recurse"
)

str(renewable_M49[[1]], max.level = 3, list.len = 3, give.attr = FALSE)
@
\begin{remark}
Here we passed \code{list(renewable\_energy\_by\_country)} to the call of \code{rrapply} in order to start application of the \code{f} function at the level of the list \code{renewable\_energy\_by\_country} itself, instead of starting at its list elements. 
\end{remark}

\subsection{Miscellaneous}

\subsubsection{Data.frames as lists}

As already discussed, base \code{rapply} recurses into all list-like objects. Since data.frames are
list-like objects, the \code{f} function always descends into the individual columns of a data.frame. Sometimes we wish to apply \code{f} to a data.fame object as a whole, instead of its individual columns, which is not possible with \code{rapply}. For this purpose, \code{rrapply} includes a convenience argument \code{dfaslist}. If \code{dfaslist = TRUE}, \code{rrapply} behaves in the same way as \code{rapply} by recursing into the individual columns of a data.frame. If \code{dfaslist = FALSE}, the \code{f} and \code{condition} functions are applied directly to the data.frame object itself and not its columns. 
<<>>=
## create a list of data.frames
oceania_df <- list(
  Oceania = lapply(
    renewable_oceania[["Oceania"]], 
    FUN = function(x) data.frame(value = unlist(x))
  )
)
## this does not work!
tryCatch({
  rrapply(
    oceania_df,
    f = function(x) subset(x, !is.na(value)), ## filter NA-rows of data.frame
    how = "replace",
    dfaslist = TRUE
  )
}, error = function(error) error$message)
## this does work
rrapply(
  oceania_df,
  f = function(x) subset(x, !is.na(value)),
  how = "replace",
  dfaslist = FALSE
)
@

\begin{remark}
Note that the same result can also be obtained using \code{feverywhere = "break"} and checking that the list element under evaluation is a data.frame:
<<eval=FALSE>>=
rrapply(
  oceania_df,
  condition = function(x) class(x) == "data.frame",
  f = function(x) subset(x, !is.na(value)),
  how = "replace",
  feverywhere = "break"
)
@
Using the \code{dfaslist} argument better reflects our purpose and is also slightly more efficient as the class of the list element is checked directly analogous to the \code{classes} argument. 
\end{remark}

\subsubsection{List attributes}

Base \code{rapply} may produce different results when using \code{how = "replace"} or \code{how = "list"} when working with list attributes. The former preserves intermediate
list attributes whereas the latter does not. To avoid unexpected behavior,
\code{rrapply} always preserves intermediate list attributes when using
\code{how = "replace"}, \code{how = "list"} or \code{how = "prune"}.  Note that if we set \code{how = "flatten"}, \code{how = "melt"} or \code{how = "unlist"} intermediate list attributes cannot be
preserved as the result is no longer a nested list.
<<>>=
## how = "list" now preserves all list attributes
na_drop_oceania_list_attr2 <- rrapply(
  renewable_oceania, 
  f = function(x) replace(x, is.na(x), 0), 
  how = "list"
)
str(na_drop_oceania_list_attr2, max.level = 2)
## how = "prune" also preserves list attributes
na_drop_oceania_attr <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  how = "prune"
)
str(na_drop_oceania_attr, max.level = 2)
@

\subsection{Using \texttt{rrapply} on data.frames}

In the previous section, the \code{dfaslist} argument is used in order to avoid recursing into the individual columns of a data.frame object. However, it can also be useful to exploit exactly this property of base \code{rapply}. A convenient way to apply a function to columns of a data.frame of a certain class is through the use of the \code{classes} argument in base \code{rapply}.\\[3mm]
For instance, suppose we wish to standardize all \code{numeric} columns in the \code{iris}
dataset by their sample mean and standard deviation:
<<>>=
iris_standard <- rapply(iris, f = scale, classes = "numeric", how = "replace")
head(iris_standard)
@
Using the \code{condition} argument in \code{rrapply}, we obtain more flexible control in selecting the columns to which \code{f} is applied. For instance, it is now straightforward to apply the \code{f} function only to the \code{Sepal} columns using the \code{.xname} argument:
<<>>=
iris_standard_sepal <- rrapply(
  iris,                    
  condition = function(x, .xname) grepl("Sepal", .xname), 
  f = scale
)
head(iris_standard_sepal)
@
Instead of \emph{mutating} columns, we can also \emph{transmute} columns (referencing
to the semantics of the \code{dplyr}-package) keeping only the columns to which
\code{f} is applied by setting \code{how = "prune"}: 
<<>>=
iris_standard_transmute <- rrapply(
  iris, 
  f = scale, 
  classes = "numeric", 
  how = "prune"
)
head(iris_standard_transmute)
@
In order to \emph{summarize} a set of selected columns, use \code{how = "flatten"}
instead of \code{how = "prune"}, as the latter preserves list
attributes --including data.frame dimensions-- which should not be kept. 
<<>>=
## summarize columns with how = "flatten"
iris_standard_summarize <- rrapply(
  iris, 
  f = summary, 
  classes = "numeric", 
  how = "flatten"
)
iris_standard_summarize
@

\end{document} 

<<echo=false>>=
options(op)
@
